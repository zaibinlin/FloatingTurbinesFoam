// k inlet

type       inletOutlet;
inletValue #codeStream
{
	codeInclude
	#{
		#include "fvCFD.H"
	#};

	codeOptions
	#{
		-I$(LIB_SRC)/finiteVolume/lnInclude \
		-I$(LIB_SRC)/meshTools/lnInclude
	#};

	codeLibs
	#{
		-lmeshTools \
		-lfiniteVolume
	#};

	code
	#{
		const IOdictionary& d = static_cast<const IOdictionary&>
		(
			dict.parent().parent()
		);

		const fvMesh& mesh = refCast<const fvMesh>(d.db());
		const label id = mesh.boundary().findPatchID("inlet");
		const fvPatch& patch = mesh.boundary()[id];

                //const scalar k_water = 0.002;
		//const scalar k_air = 0.04;

		scalarField k(patch.size(), scalar($k_water));

		forAll(k, i)
		{
			const scalar z = patch.Cf()[i][2];
			if (z>$ZWL) // Above water level
			{	
				k[i] =$k_air;
					
			} 
			else k[i] = $k_water;	 
		};

                //Info << "Set k value:" << k << endl;

		k.writeEntry("",os);

	#};

};
value #codeStream
{
	codeInclude
	#{
		#include "fvCFD.H"
	#};

	codeOptions
	#{
		-I$(LIB_SRC)/finiteVolume/lnInclude \
		-I$(LIB_SRC)/meshTools/lnInclude
	#};

	codeLibs
	#{
		-lmeshTools \
		-lfiniteVolume
	#};

	code
	#{
		const IOdictionary& d = static_cast<const IOdictionary&>
		(
			dict.parent().parent()
		);

		const fvMesh& mesh = refCast<const fvMesh>(d.db());
		const label id = mesh.boundary().findPatchID("inlet");
		const fvPatch& patch = mesh.boundary()[id];

		scalarField k(patch.size(), scalar($k_water));

		forAll(k, i)
		{
			const scalar z = patch.Cf()[i][2];
			if (z>$ZWL) // Above water level
			{	
				k[i] = $k_air;	
			} 
			else k[i] = $k_water;	 
		};

		k.writeEntry("",os);

	#};

};
